---
title: "Intro To R"
author: "Maths Skills Centre"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r import NHANES data for developer, include = FALSE}
healthData <- readr::read_csv("../data/NHANES.csv")
```

```{r import iris data for developer, include = FALSE}
flowerData <- readr::read_csv("../data/iris.csv")
```

This document contains all the materials covered in the Introduction to R workshop of the Maths Skills Centre.

# Overview of RStudio

> Questions:  
> 1. What are the four panels in RStudio?  
> 2. How is a project set up in RStudio?  
> 3. Where do we save files for RStudio to use?  
> 
> 
> Objectives:  
> 1. Navigate the RStudio environment.   
> 2. Set up an RStudio project for the workshop.  
> 3. Save the workshop files from the vle into the project working directory.

## Navigating the RStudio environment
RStudio has four panels. When RStudio is opened for the first time, only three are visible:

```{r, echo=FALSE, fig.cap="When RStudio is first started, three panels are visible."}
knitr::include_graphics("../img/three-panel-RStudio.png")
```

The fourth panel appears after we open a new *script*. Do so by pressing on the icons highlighted below:

```{r, echo=FALSE, fig.cap='Open a script by pressing the "New File" button, followed by "R Script".'}
knitr::include_graphics("../img/open-script.png")
```

Now you should see four panels, as shown below:
```{r, echo=FALSE, fig.cap="After opening a new script, RStudio has four panels."}
knitr::include_graphics("../img/four-panel-RStudio.png")
```

What is the purpose of these panels?

* *Top left*: this area is for the ***script**. A script is
a text file in which we write R code. The script can be saved, 
such that we can return to coding and use our code at a later
date. Saving a script also allows us to share our analysis
with colleagues.  
* *Bottom left*: this is the **console** area. Here we can also
write code, however this is not saved when we close R. It is
therefore better practice to code from the script. Additionally,
RStudio returns output to us in the console. For example, a 
response to the command `4 + 4` will appear in the console.    
* *Top right*: this is the *environment* area. Here the names of
everything we import into or create in RStudio will appear. For 
example, when we import a spreadsheet into RStudio, it appears
in the environment.  
* *Bottom right*: this is a multifunctional area, including our
file directories and plots. 

## Setting up a project in RStudio
When working with RStudio, for example for an analysis or even
this workshop, it is good practice to have all relevant files in
one folder. This makes it easier to locate files and to share
our work with colleagues. This folder is called our
**working directory**. 

A convenient way to set and save a working directory is through
the RStudio *projects* functionality. Here we will set up an 
RStudio project for this workshop:

* Under the `File` menu in the top left of RStudio, press 
`New Project`, then `New Directory`, then `New Project`.
* Provide a `Directory name` - this will be the name of the 
newly created folder. For example, you could name it 
`msc-intro-R`. 
* Under `Create project as subdirectory of`, select a convenient 
location for this new folder. For example, this could be your
desktop or your `Documents` folder. 

RStudio should now have refreshed, showing us our project 
environment. Open a new script, as we did in the previous 
section, such that the four-panel view is restored. Then press on
the `Save` icon to the right of the `New File` button. Give the
file a convenient name, such as `msc-intro-R`. It will then 
appear in the bottom right of RStudio as `msc-intro-R.R`. 

## Saving data files in our working directory
As mentioned above, one of the features of the RStudio project
is that it allows us to have all relevant files in one folder.
We will download the data files for this workshop and save them
inside our project directory. 

*Complete once it's clear where and how the files are stored*.















# Writing code in a script

> Questions:  
> 1. What are the common terms used to describe R code?  
> 2. What is the structure of commands in R?  
> 3. How can data be entered into RStudio manually?  
> 4. How are notes written alongside code?  
> 5. How and why do we install packages?
> 
> 
> Objectives:  
> 1. Define the following R terminology: `object`, 
> `assign`, `call`, `function`, `arguments` and `options`.   
> 2. Use a built-in `function` and control its working 
> with an `argument` and an `option`.  
> 3. Assign values to a named `vector` 
> using the `c()` function.  
> 4. Write `comments` to make a script easier to interpret.  
> 5. Install and load the `readr` package.  

## Common R terminology

### `Assign` a value to an `object`
In R, everything that we create or import is saved as an `object`. 
An `object` has a name, with which we can refer to it. 
When we save something as an `object`, this is referred to as `assigning` something
to that object. 
`Assigning` is done using the `<-` syntax, as exemplified below. If we wanted to
save the number 6 under the name `Six`, we would run:

```{r assign value to object example}
Four <- 4
```

After running this code, we see `Four` has appeared in the environment window. 
This confirms that we have successfully `assigned` a value to an `object`. 

### `Calling` a built-in `function` with one `argument`
Most commands in R involve `functions`. 
A `function` is an in-built piece of code that performs a specific task.
This saves us from having to write the code required for the task ourselves.
When a `function` is used in R, this is referred to as `calling` the `function`.
Usually, a `function` is `called` with one or more inputs - 
these are called `arguments`.

Let us take the `round`()` function as an example. 
This function rounds a supplied value. 
For example, we `call` the `round()` `function` on the value 3.14. 
The value 3.14 is an `argument` in our `call`:

```{r, eval = FALSE}
round(3.14)
```

R then returns in the console:

```{r, echo = FALSE}
round(3.14)
```

An argument can also be an object, as you will see in the challenge at the end of this section.

### Including an `argument` with an `option` in a `function` call
Often the behaviour of a `function` can be manipulated using 
`arguments` which take `options`. 
These `options` have defaults, 
which are assumed if we do not specify an alternative.

For example, the `round()` function takes the `digits` argument, for which
the default is `digits = 0`. That is why so far, `round()` has returned
values with 0 digits behind the decimal.

We can specify an alternative `option` for the `digits` `argument`, for example
for a single digit behind the decimal:

```{r}
round(3.14, digits = 1)
```

<details>
<summary>**Challenge**: assign the value 6.667 to an object named `number`. Then, call the `round()` function on the object `number`. Ensure that `round()` returns two digits behind the decimal. Find the solution in the drop-down.</summary>
<br>
```{r}
number <- 6.667
round(number, digits = 2)
```
</details>

### `Vectors` using the `c()` `function`
So far, we have worked with `objects` that contained a single value.
Often we are working with multiple data points. 
In R, multiple data points can be saved inside one `object` as a `vector`. 
A `vector` is a collection of data points of the *same type* 
(e.g. numbers of words). 
`Vectors` are formed by calling the `c()` function, with data provided between
the brackets, separated by commas. For example:

```{r}
numbers <- c(1,2,3,4,5,6)
```

`Vectors` can also contain words, which we call `strings` in R. Ensure that 
`strings` are always wrapped in quotes:

```{r}
colours <- c("red", "blue", "green")
```

Later in this workshop we will learn how to import data without 
needing to manually type data into `c()`.

### Writing `comments` to enhance script readability
As we progress through this workshop, our script will fill up with many
lines of code. To enhance readability for ourselves and for colleagues 
who may use our script at a later date, we include comments.

Any text in R that is preceded by a `#` is ignored by R and treated as a comment.
For example, if we were to comment when creating our vector `numbers`:

```{r}
# create a vector of the numbers 1 to 6
numbers <- c(1,2,3,4,5,6)
```

<details>
<summary>**Challenge**: assign the city names London, Manchester and Newcastle to an object named `cities`. Include a comment to increase the interpretability of your code. Find the solution in the drop-down.</summary>
<br>
```{r}
# a vector of city names
cities <- c("London", "Manchester", "Newcastle")
```
</details>

### Installing and loading packages
So far, we have used the built-in functions `round()` and `c()`. 
R has many useful functions, some of which do not come built-in.
Rather than releasing individual functions, collections of functions are
released together in packages.
Therefore, to use an external function, we need to install and load the
appropriate package. 

Working with packages is analogous to using a new light bulb:
1. First, we install the package in R using the `install.packages()` function.
This is analogous to screwing a new light bulb into the socket - we only
need to do this **once**.  
2. Then, every time we open RStudio and want to use the package, we need to load it 
using the `library()` function. This is analogous to using a light bulb - every 
time we enter the room, we need to turn on the light again.

Let us take the `readr` package as an example. In the next section, we will use
a function from this package. First, we install the package. You can run the 
following line from the console rather than the script, as we do not want the
package to install again every time we run the script: 

```{r install readr, eval = FALSE}
# install the readr package
install.packages("readr")
```

Then we load the package. It is good practice to load all packages at the top
of our script. This way, it is easy for another user to identify whether they
need to install any packages before running our script. Therefore, paste the
following code at or near the top of your script:

```{r load readr}
# loading a package
library("readr")
```

You may receive a warning similar to the one above. This warning is usually not 
something to worry about. 

As we progress through the workshop, we will encounter other packages.
You will get a chance to further practice installing and loading then. 


























# Importing and viewing data

> Questions:  
> 1. How is data from a .csv file imported into R?  
> 2. What is the difference between a `tibble` and a `data frame`?  
> 3. How is a summary view of a `tibble` viewed in R?  
> 
> Objectives:  
> 1. Use `read_csv()` to import data from a .csv file as a `tibble`.  
> 2. Be aware of differences between a `tibble` and a `data frame`.  
> 3. Use `view()`, `head()`, and `summary()` to inspect a `tibble`.  

## Importing `.csv` data into RStudio
In the previous section we learned how to type data into RStudio using 
the `c()` function. More commonly, we directly import data from 
a `.csv` spreadsheet. We will use the `read_csv()` function from 
the `readr` package, which we loaded in the previous section.

We will use a subset from the NHANES data, which is a public health 
survey in the US. This data should be located inside the `data` folder
of your working directory. We import the data as follows:

```{r import NHANES data for learners, eval = FALSE}
healthData <- read_csv("data/NHANES.csv")
```

We can see that `healthData` has appeared in the environment panel. 
This `object` is a `tibble`, which you can think of as the RStudio 
equivalent of a spreadsheet. 
The main difference is that in `tibbles`, each column is a `vector`. 
Recall that within a `vector`, data must be of the same type.
Therefore, individual columns in a `tibble` are always of one data type. 

## A note on `tibble` vs `data frame`
In the previous section we created the `tibble` `healthData`. 
As you come to using RStudio independently, you are likely to come 
across the `data frame`. 
The `tibble` and the `data frame` are very similar - in fact, `tibble` is a 
type of `data frame`.
In this workshop we limit ourselves to `tibble`, as its an updated version of
the `data frame`. 
However, in many online tutorials, `data frame` is used as the tutorials 
are a few years old.
To find out more about the difference between `tibble` and `data frame`,
see [this blog](https://www.jumpingrivers.com/blog/the-trouble-with-tibbles/).

## Viewing a `tibble`
We will cover four ways to quickly inspect the `tibble` that we have just created. 
Firstly, we can view `healthData` as a whole, analogous to the view that Excel
would provide us with. 
We can do this using the `View()` function (note the capital `V`). 
The code below will open a new tab in RStudio, allowing us to scroll through
the data:

```{r view healthData, eval=FALSE}
View(healthData)
```

Alternatively, we can ask RStudio to display the first six rows of `healthData`
using the `head()` function:

```{r head healthData}
head(healthData)
```

This output is useful for a few checks:

* Have the column names imported properly?
* Have columns been imported as the correct types? Below the column names, we see data types. In our case, `<dbl>` and `<chr>`, which stand for double and character, respectively. A double column that has been imported as a character column, for example, could give us trouble in downstream analyses.
* Do the first few rows of data look as we expect them to look?

We may also want to check that the `tibble` has the same number of 
rows and columns as we expect. We can do so using the functions `nrow()` 
and `ncol()`, respectively:

```{r nrow and ncol healthData}
nrow(healthData)
ncol(healthData)
```


Finally, we may want to have a look at the spread of our continuous data.
We can obtain a view of this using the `summary()` function:

```{r summary healthData}
summary(healthData)
```

This output shows us for each column with continuous data the smallest and 
largest values (`Min.` and `Max.`), the 1st and 3rd quantiles, the median and the 
mean. 

In addition, the number of `NA's` are displayed. An empty cell in RStudio
is denoted by `NA`. For example, our `Weight` column has 431 `NA's`, i.e. 431 
missing values. If we were not expecting missing values in our data, we would 
need to investigate where these `NA's` came from.

<details>
<summary>**Challenge**: Import the csv file `iris.csv` as a `tibble` named `flowerData`. This file contains data on the length and width of sepals and petals of three species of iris. Then, find out the following about the `tibble`:
<ul>
  <li>What are the column names?</li>
  <li>How many rows and columns does the data contain?</li>
  <li>What is the mean of sepal length?</li>
  <li>How many NAs does sepal width contain?</li>
</ul> 
Find the solution in the drop-down.
</summary>
<br>
```{r import iris for learners, eval = FALSE}
flowerData <- read_csv("data/iris.csv") # import the data
```

```{r iris import results}
head(flowerData) # find the column names in head() output
nrow(flowerData) # number of rows
ncol(flowerData) # number of columns
summary(flowerData) # mean of sepal length is 5.843 and sepal width has no NAs
```

</details>

# Data wrangling

> Questions:  
> 1. How can rows from a `tibble` be selected?  
> 2. How can columns from a `tibble` be selected?  
> 3. How can multiple data wrangling steps be combined into one command?  
> 4. How can new columns be created based on existing columns?  
> 5. What is a factor variable in R? [*if there is time*]   
> 6. How are string variables converted to factor variables? [*if there is time*]   
> 7. How can group-specific summary statistics be obtained?  
> 8. How can a `tibble` be saved as a .csv file?
> 
> Objectives:  
> 1. Use `filter()` to select rows from a `tibble`.   
> 2. Use `select()` to select columns from a `tibble`.   
> 3. Use the pipe operator, `%>%`, to link commands together.  
> 4. Use `mutate()` to create new columns based on existing columns.  
> 5. Describe the difference between a character variable and a factor variable. 
> [*if there is time*]  
> 6. Use `as_factor()` to convert a character variable to a factor variable. 
> [*if there is time*]  
> 7. Use `drop_na()`, `group_by()`, `summarise()`, `n()`, `mean()` and `sd()` to obtain 
> group-specific summary statistics.   
> 8. Use `write_csv()` to save a `tibble` as a .csv file. 

Now that our data has been loaded in RStudio as a `tibble`, we proceed
to the stage of "data wrangling": manipulating the data such that it
is ready for downstream analyses. 

## Selecting rows and columns
We may be interested in particular rows and/or columns of our data in downstream
analyses. We can select rows using the `filter()` function and columns
using the `select()` function. Both of these functions are part of the `dplyr`
package. We will first ensure that these functions are loaded in RStudio.
Then we will learn how to use them to filter rows and columns.

<details>
<summary>**Challenge**: Install and load the `dplyr` package, such that you can use `filter()` and `select()` in this workshop.

Find the solution in the drop-down.
</summary>
<br>
Recall that in order to use `read_csv()` from the `readr` package, we needed to 
install `readr` using `install.packages()`, followed by loading the package
using `library()`.

```{r install dplyr for learners, eval = FALSE}
install.packages("dplyr") # install dplyr, only needs to be done once
```

```{r load dplyr, message=FALSE, warning = FALSE}
library(dplyr) # load dplyr, needs to be done every time RStudio is started up
```

</details>
  
To select particular rows, we use the `filter()` function.
This function takes our `tibble` of interest (`healthData`)
and a criterion for filtering. For example, to 
select rows with participants of the female sex from `healthData`,
then the criterion is `Sex == "female"` (note the use of the double `=`):

```{r filter female data}
filter(healthData, Sex == "female")
```

We could also filter based on a column with continuous data. For example, if
we wanted to retain the data on participants below 170 cm:

```{r filter height data}
filter(healthData, Height < 170)
```

The function for selecting columns is `select()`. The names of the columns
that we want to keep are included inside `select()` as a vector. For example,
to retain the `ID` and `Height` columns:

```{r select ID and Height data}
select(healthData, c(ID, Height))
```

We could also specify columns to exclude using `-c()`. For example, to exclude
the `Weight` column:

```{r select all but Weight data}
select(healthData, -c(Weight))
```

Note that the output from each of these commands can be saved as an object.
For example, to save `healthData` with the `Weight` column excluded:

```{r save noWeight, eval = FALSE}
noWeight <- select(healthData, -c(Weight))
```

## Linking data wrangling commands using `%>%`
Often when data is wrangled, multiple steps need to be combined. For example, we
might want to exclude the `Weight` column from `healthData` and only retain
data on participants of the female `Sex`. The long way to do this would be 
to create a new object at each step of the data wrangling:

```{r long way select and filter, eval = FALSE}
noWeight <- select(healthData, -c(Weight))
noWeightFemale <- filter(noWeight, Sex == "female") 
```

Note that in the `filter()` step, we specify `noWeight` as the data, rather
than `healthData`. So here we `select()` for columns and then `filter()` for 
rows on the reduced data from `select()`.

This operation would be easier if we could link the `select()` and `filter()` steps 
together. This can be done using the pipe operator, `%>%`. When reading the 
pipe operator in code, think of it as saying "then". In the example below, we
select all but the `Weight` column, **then** we filter for participants of the 
female `Sex`:

```{r select then filter healthData}
noWeightFemale <- select(healthData, -c(Weight)) %>%
  filter(Sex == "female")
```

Notice that in the `filter()` step, we no longer specify the data. This is 
because the pipe operator passes on the data from the `select()` step. 

It is common to provude the `tibble` by itself in the first command, such that the chain becomes:

```{r select then filter healthData 2}
noWeightFemale <- healthData %>%
  select(-c(Weight)) %>%
  filter(Sex == "female")
```

<details>
<summary>**Challenge**: Create an object named `setosaSepal`, a subset of `flowerData`, with:
<ul>
  <li>Only flowers of the `Setosa` variety.</li>
  <li>Only the sepal length and sepal width columns.</li>
</ul> 
Find the solution in the drop-down.
</summary>
<br>
```{r make smallSetosa}
setosaSepal <- flowerData %>%
  filter(variety == "Setosa") %>%
  select(c(sepal.length, sepal.width))
```

</details>


## Creating new columns using `mutate()`
Often we want to add new columns to our `tibble`, based on existing columns. 
For example, we may want to add a `BMI` column to our `healthData` object, 
based on the `Height` and `Weight` columns. 
The BMI is calculated by dividing `Weight` by `Height` squared. 
Since `Height` in `healthData` is in cm, we divide `Height` by 100.
We create the `BMI` column using `mutate()`:

```{r create healthDataBMI}
healthDataBMI <- healthData %>%
  mutate(BMI = Weight/(Height/100)^2)
```

Using `head()` we can see our new column:

```{r head healthDataBMI}
head(healthDataBMI)
```

## Using `as_factor()` for categorical variables
When we import categorical variables as part of a `tibble`, they appear
as a `character` column. See for example the `Sex` column in healthData:

```{r head healthData 2}
head(healthData)
```

A `character` column in RStudio is a column with words (also known as "strings"). 
For downstream analyses, it is often useful to convert a categorical `character`
column into a `factor` column. This has the following advantages:

* A character column is prone to typos which can go unseen. In a factor column, there is a limited set of categories (known as levels), such that typos can be spotted easily.
* A character column does not specify an order for the categories, which can complicate downstream analyses. In a factor column, the levels can be ordered in a specific way, such that plots and models treat the column as we would like them to (e.g. plot the 12 months of the year in the correct order, rather than alphabetically). 

We can convert a character column into a factor using the `as_factor()` function
from the `forcats` package. We do this inside `mutate()`. Ensure that you have the 
`forcats` package installed before you run the code below.

```{r sex factor healthData, warning = FALSE}
library(forcats) # load the required package

healthDataFactor <- healthData %>%
  mutate(Sex = as_factor(Sex))
```

Using `head()`, we can see that `Sex` has become a factor. 
See the `<fct>` under `Sex`:

```{r head check healthDataFactor}
head(healthDataFactor)
```

We can check that our variable is free of typos by checking the levels 
(i.e. categories) inside our variable using the `pull()` and `levels()` functions:

```{r levels healthDataFactor}
healthDataFactor %>%
  pull(Sex) %>%
  levels()
```

This shows us that our factor variable is free of typos, since we have only two 
levels with spelling as expected.

We can change the order of the levels using `fct_relevel()` inside `mutate()`:

```{r relevel healthDataFactor}
healthDataFactorRelevel <- healthDataFactor %>%
  mutate(Sex = fct_relevel(Sex, "female", "male"))
```

We then see that the levels have been reordered:

```{r levels healthDataFactorRelevel}
healthDataFactorRelevel %>%
  pull(Sex) %>%
  levels()
```

Reordering factor levels will come in handy later on when we learn how to plot. 

<details>
<summary>**Challenge**: Create an object named `flowerDataFactor`, with the `variety` column as a factor. Ensure that the levels are ordered as "Versicolor", "Virginica", "Setosa".
Find the solution in the drop-down.
</summary>
<br>
```{r flowerDataFactor}
flowerDataFactor <- flowerData %>%
  mutate(variety = as_factor(variety)) %>%
  mutate(variety = fct_relevel(variety,
                               "Versicolor", "Virginica", "Setosa"))

#check that reordering the factor levels worked
flowerDataFactor %>%
  pull(variety) %>%
  levels()
```

</details>

## Obtaining group-specific summary statistics
Earlier in this workshop we used `summary()` to obtain summary statistics for 
each column in our `tibble`. Alternatively, we may want to obtain group-specific summary statistics. For example, we may want summary statistics for `Height`, 
grouped by `Sex`, from our `healthData`. 

In this example we will ask RStudio to return the mean, standard deviation and 
number of observations for `Height`, grouped by `Sex`. First, we group the data by `Sex` using 
`group_by()`. We then calculate summary statistics using `summarise()`. Inside `summarise()` 
we specify the values that we want. We request the number of observations per group using
`n()`, the mean height using `mean()` and the standard deviation of height using `sd()`. 
Each of these values is given a name, which we specify ahead of the `=` signs.

```{r summarise height by Sex with NAs}
healthData %>%
  group_by(Sex) %>%
  summarise(n = n(),
            mean = mean(Height),
            sd = sd(Height))
```

While `n()` resulted in an output, `mean()` and `sd()` resulted in NAs. 
These functions return NA when there is at least one NA in the column of interest 
(i.e. an empty cell).
We can circumvent this by dropping the NAs from `Height` using `drop_na()` from the `tidyr` package.
Make sure that you install the `tidyr` package before running the code below. 

```{r summarise height by Sex without NAs, warning = FALSE}
library(tidyr) #load package for drop_na()

healthData %>%
  drop_na(Height) %>% #remove NAs in Height
  group_by(Sex) %>%
  summarise(n = n(),
            mean = mean(Height),
            sd = sd(Height))
```

Note that we now have less observations (lower number under `n`), since we have dropped the 
empty rows. 

## Exporting a `tibble` as a `.csv` file
Once data wrangling is completed, we may want to export our `tibble` as a `.csv` file. This
allows us to easily share the data with others. For example, we may want to export our summary 
table from the last subsection.

To do this, we create an object for the sumamry table. Then we export the `tibble` using 
the `write_csv()` function from the `readr` package. We provide a name for the file inside
`write_csv()` within quotes. By default, the file is saved in our working directory. 

```{r export healthData summary table, warning = FALSE}
summaryHeight <- healthData %>% #give the summary table a name
  drop_na(Height) %>% 
  group_by(Sex) %>%
  summarise(n = n(),
            mean = mean(Height),
            sd = sd(Height))

write_csv(summaryHeight, "summaryHeight.csv")
```

After running this code, check in your working directory that the file has indeed been created. 

<details>
<summary>**Challenge**: Create a `tibble` with the number of observations, mean and standard deviation of sepal width, grouped by variety. Name this object `summarySepalWidth` and save it as a `.csv` file in your working directory. 
Find the solution in the drop-down.
</summary>
<br>
```{r summarySepalWidth}
summarySepalWidth <- flowerData %>% 
  group_by(variety) %>%
  summarise(n = n(),
            mean = mean(sepal.width),
            sd = sd(sepal.width))

write_csv(summarySepalWidth, "summarySepalWidth.csv")
```

Notice that no `drop_na()` is not required, since `sepal.width` is free of NAs. 

</details>

